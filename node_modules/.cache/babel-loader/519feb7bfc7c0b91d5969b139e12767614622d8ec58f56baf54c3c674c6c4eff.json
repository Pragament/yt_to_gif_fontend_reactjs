{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\ksais\\\\OneDrive\\\\Desktop\\\\YOTUBE\\\\frontend\\\\yt_to_gif_fontend_reactjs\\\\src\\\\App.js\",\n  _s = $RefreshSig$();\nimport React, { useState, useEffect, useRef } from 'react';\nimport './App.css';\nimport VideoInput from './components/VideoInput';\nimport VideoPreview from './components/VideoPreview';\nimport CropConfig from './components/CropConfig';\nimport GIFGallery from './components/GIFGallery';\nimport { downloadVideo, uploadVideo, getVideoStatus, getVideoUrl } from './services/api';\nimport { processGIFs, getGIFStatus, clearGIFs } from './services/gifService';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nfunction App() {\n  _s();\n  const [videoId, setVideoId] = useState(null);\n  const [videoStatus, setVideoStatus] = useState(null);\n  const [videoUrl, setVideoUrl] = useState(null);\n  const [cropMethod, setCropMethod] = useState('grid');\n  const [gifConfigs, setGifConfigs] = useState([]);\n  const [gifTasks, setGifTasks] = useState({});\n  const [videoDimensions, setVideoDimensions] = useState({\n    width: 0,\n    height: 0\n  });\n  const [lineOverlays, setLineOverlays] = useState({\n    horizontal: [],\n    vertical: []\n  });\n  const [dragRegions, setDragRegions] = useState([]);\n  const statusIntervalRef = useRef(null);\n  const gifStatusIntervalRef = useRef(null);\n  const isClearingRef = useRef(false);\n\n  // Poll video status\n  useEffect(() => {\n    if (videoId) {\n      const checkStatus = async () => {\n        try {\n          const status = await getVideoStatus(videoId);\n          setVideoStatus(status);\n          if (status.status === 'ready' && status.video_path) {\n            const url = getVideoUrl(videoId);\n            setVideoUrl(url);\n\n            // Get video dimensions\n            const video = document.createElement('video');\n            video.src = url;\n            video.onloadedmetadata = () => {\n              setVideoDimensions({\n                width: video.videoWidth,\n                height: video.videoHeight\n              });\n            };\n            if (statusIntervalRef.current) {\n              clearInterval(statusIntervalRef.current);\n              statusIntervalRef.current = null;\n            }\n          } else if (status.status === 'error') {\n            if (statusIntervalRef.current) {\n              clearInterval(statusIntervalRef.current);\n              statusIntervalRef.current = null;\n            }\n          }\n        } catch (error) {\n          console.error('Error checking video status:', error);\n        }\n      };\n      checkStatus();\n      statusIntervalRef.current = setInterval(checkStatus, 1000);\n    }\n    return () => {\n      if (statusIntervalRef.current) {\n        clearInterval(statusIntervalRef.current);\n      }\n    };\n  }, [videoId]);\n\n  // Poll GIF status\n  useEffect(() => {\n    // Don't start polling if we're clearing or if there are no tasks\n    if (!videoId || isClearingRef.current || Object.keys(gifTasks).length === 0) {\n      return;\n    }\n    const checkGIFStatus = async () => {\n      // Don't check if we're clearing\n      if (isClearingRef.current) {\n        return;\n      }\n      try {\n        const status = await getGIFStatus(videoId);\n        const newGifTasks = status.gif_tasks || {};\n\n        // Don't update if we're clearing\n        if (isClearingRef.current) {\n          return;\n        }\n\n        // Only update if there are actually tasks\n        if (Object.keys(newGifTasks).length > 0) {\n          setGifTasks(newGifTasks);\n\n          // Check if all tasks are completed or failed\n          const allDone = Object.values(newGifTasks).every(task => task.status === 'completed' || task.status === 'failed');\n          if (allDone && gifStatusIntervalRef.current) {\n            clearInterval(gifStatusIntervalRef.current);\n            gifStatusIntervalRef.current = null;\n          }\n        } else {\n          // Backend has no tasks, stop polling\n          if (gifStatusIntervalRef.current) {\n            clearInterval(gifStatusIntervalRef.current);\n            gifStatusIntervalRef.current = null;\n          }\n          setGifTasks({});\n        }\n      } catch (error) {\n        console.error('Error checking GIF status:', error);\n      }\n    };\n    checkGIFStatus();\n    gifStatusIntervalRef.current = setInterval(checkGIFStatus, 1000);\n    return () => {\n      if (gifStatusIntervalRef.current) {\n        clearInterval(gifStatusIntervalRef.current);\n        gifStatusIntervalRef.current = null;\n      }\n    };\n  }, [videoId, gifTasks]);\n  const handleYouTubeDownload = async url => {\n    try {\n      const result = await downloadVideo(url);\n      setVideoId(result.video_id);\n      setVideoStatus({\n        status: 'downloading',\n        progress: 0\n      });\n    } catch (error) {\n      console.error('Error downloading video:', error);\n      alert('Error downloading video: ' + error.message);\n    }\n  };\n  const handleVideoUpload = async file => {\n    try {\n      const result = await uploadVideo(file);\n      setVideoId(result.video_id);\n      setVideoStatus({\n        status: 'uploading',\n        progress: 0\n      });\n    } catch (error) {\n      console.error('Error uploading video:', error);\n      alert('Error uploading video: ' + error.message);\n    }\n  };\n  const handleProcessGIFs = async (configs, method, params) => {\n    if (!videoId) {\n      alert('Please download or upload a video first');\n      return;\n    }\n    try {\n      const result = await processGIFs(videoId, configs, method, params);\n      setGifTasks(result.gif_tasks || {});\n    } catch (error) {\n      console.error('Error processing GIFs:', error);\n      alert('Error processing GIFs: ' + error.message);\n    }\n  };\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"App\",\n    children: [/*#__PURE__*/_jsxDEV(\"header\", {\n      className: \"App-header\",\n      children: [/*#__PURE__*/_jsxDEV(\"h1\", {\n        children: \"GIF Generator\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 171,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"p\", {\n        children: \"Generate multiple GIFs from videos\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 172,\n        columnNumber: 9\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 170,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"App-input-section\",\n      children: /*#__PURE__*/_jsxDEV(VideoInput, {\n        onYouTubeDownload: handleYouTubeDownload,\n        onVideoUpload: handleVideoUpload,\n        videoStatus: videoStatus\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 176,\n        columnNumber: 9\n      }, this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 175,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"App-container\",\n      children: [/*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"App-left\",\n        children: /*#__PURE__*/_jsxDEV(VideoPreview, {\n          videoUrl: videoUrl,\n          videoStatus: videoStatus,\n          onDimensionsChange: setVideoDimensions,\n          lineOverlays: lineOverlays,\n          dragEnabled: cropMethod === 'drag',\n          dragRegions: dragRegions,\n          onDragRegionsChange: setDragRegions,\n          videoDimensions: videoDimensions,\n          cropMethod: cropMethod,\n          onLinePositionUpdate: cropMethod === 'lines' ? (type, index, value) => {\n            // Update lineOverlays immediately for visual feedback\n            if (type === 'horizontal') {\n              setLineOverlays(prev => {\n                const newHorizontal = [...(prev.horizontal || [])];\n                if (newHorizontal[index] !== undefined) {\n                  newHorizontal[index] = value;\n                }\n                return {\n                  ...prev,\n                  horizontal: newHorizontal\n                };\n              });\n            } else if (type === 'vertical') {\n              setLineOverlays(prev => {\n                const newVertical = [...(prev.vertical || [])];\n                if (newVertical[index] !== undefined) {\n                  newVertical[index] = value;\n                }\n                return {\n                  ...prev,\n                  vertical: newVertical\n                };\n              });\n            }\n          } : undefined\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 185,\n          columnNumber: 11\n        }, this)\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 184,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"App-right\",\n        children: /*#__PURE__*/_jsxDEV(CropConfig, {\n          cropMethod: cropMethod,\n          onCropMethodChange: setCropMethod,\n          videoDimensions: videoDimensions,\n          gifConfigs: gifConfigs,\n          onGifConfigsChange: setGifConfigs,\n          onProcessGIFs: handleProcessGIFs,\n          videoId: videoId,\n          videoReady: (videoStatus === null || videoStatus === void 0 ? void 0 : videoStatus.status) === 'ready',\n          onLineOverlaysChange: setLineOverlays,\n          dragRegions: dragRegions,\n          onDragRegionsChange: setDragRegions\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 219,\n          columnNumber: 11\n        }, this)\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 218,\n        columnNumber: 9\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 183,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"App-gallery\",\n      children: /*#__PURE__*/_jsxDEV(GIFGallery, {\n        gifTasks: gifTasks,\n        onClearGIFs: async () => {\n          // Set clearing flag\n          isClearingRef.current = true;\n\n          // Stop polling immediately\n          if (gifStatusIntervalRef.current) {\n            clearInterval(gifStatusIntervalRef.current);\n            gifStatusIntervalRef.current = null;\n          }\n\n          // Clear frontend state immediately\n          setGifTasks({});\n\n          // Clear backend\n          if (videoId) {\n            try {\n              await clearGIFs(videoId);\n            } catch (error) {\n              console.error('Error clearing GIFs from backend:', error);\n            }\n          }\n\n          // Reset clearing flag after a short delay\n          setTimeout(() => {\n            isClearingRef.current = false;\n          }, 500);\n        }\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 236,\n        columnNumber: 9\n      }, this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 235,\n      columnNumber: 7\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 169,\n    columnNumber: 5\n  }, this);\n}\n_s(App, \"fSIlvVsZTO7jA8x8HJFaK4xWCZU=\");\n_c = App;\nexport default App;\nvar _c;\n$RefreshReg$(_c, \"App\");","map":{"version":3,"names":["React","useState","useEffect","useRef","VideoInput","VideoPreview","CropConfig","GIFGallery","downloadVideo","uploadVideo","getVideoStatus","getVideoUrl","processGIFs","getGIFStatus","clearGIFs","jsxDEV","_jsxDEV","App","_s","videoId","setVideoId","videoStatus","setVideoStatus","videoUrl","setVideoUrl","cropMethod","setCropMethod","gifConfigs","setGifConfigs","gifTasks","setGifTasks","videoDimensions","setVideoDimensions","width","height","lineOverlays","setLineOverlays","horizontal","vertical","dragRegions","setDragRegions","statusIntervalRef","gifStatusIntervalRef","isClearingRef","checkStatus","status","video_path","url","video","document","createElement","src","onloadedmetadata","videoWidth","videoHeight","current","clearInterval","error","console","setInterval","Object","keys","length","checkGIFStatus","newGifTasks","gif_tasks","allDone","values","every","task","handleYouTubeDownload","result","video_id","progress","alert","message","handleVideoUpload","file","handleProcessGIFs","configs","method","params","className","children","fileName","_jsxFileName","lineNumber","columnNumber","onYouTubeDownload","onVideoUpload","onDimensionsChange","dragEnabled","onDragRegionsChange","onLinePositionUpdate","type","index","value","prev","newHorizontal","undefined","newVertical","onCropMethodChange","onGifConfigsChange","onProcessGIFs","videoReady","onLineOverlaysChange","onClearGIFs","setTimeout","_c","$RefreshReg$"],"sources":["C:/Users/ksais/OneDrive/Desktop/YOTUBE/frontend/yt_to_gif_fontend_reactjs/src/App.js"],"sourcesContent":["import React, { useState, useEffect, useRef } from 'react';\nimport './App.css';\nimport VideoInput from './components/VideoInput';\nimport VideoPreview from './components/VideoPreview';\nimport CropConfig from './components/CropConfig';\nimport GIFGallery from './components/GIFGallery';\nimport { downloadVideo, uploadVideo, getVideoStatus, getVideoUrl } from './services/api';\nimport { processGIFs, getGIFStatus, clearGIFs } from './services/gifService';\n\nfunction App() {\n  const [videoId, setVideoId] = useState(null);\n  const [videoStatus, setVideoStatus] = useState(null);\n  const [videoUrl, setVideoUrl] = useState(null);\n  const [cropMethod, setCropMethod] = useState('grid');\n  const [gifConfigs, setGifConfigs] = useState([]);\n  const [gifTasks, setGifTasks] = useState({});\n  const [videoDimensions, setVideoDimensions] = useState({ width: 0, height: 0 });\n  const [lineOverlays, setLineOverlays] = useState({ horizontal: [], vertical: [] });\n  const [dragRegions, setDragRegions] = useState([]);\n  const statusIntervalRef = useRef(null);\n  const gifStatusIntervalRef = useRef(null);\n  const isClearingRef = useRef(false);\n\n  // Poll video status\n  useEffect(() => {\n    if (videoId) {\n      const checkStatus = async () => {\n        try {\n          const status = await getVideoStatus(videoId);\n          setVideoStatus(status);\n          \n          if (status.status === 'ready' && status.video_path) {\n            const url = getVideoUrl(videoId);\n            setVideoUrl(url);\n            \n            // Get video dimensions\n            const video = document.createElement('video');\n            video.src = url;\n            video.onloadedmetadata = () => {\n              setVideoDimensions({\n                width: video.videoWidth,\n                height: video.videoHeight\n              });\n            };\n            \n            if (statusIntervalRef.current) {\n              clearInterval(statusIntervalRef.current);\n              statusIntervalRef.current = null;\n            }\n          } else if (status.status === 'error') {\n            if (statusIntervalRef.current) {\n              clearInterval(statusIntervalRef.current);\n              statusIntervalRef.current = null;\n            }\n          }\n        } catch (error) {\n          console.error('Error checking video status:', error);\n        }\n      };\n      \n      checkStatus();\n      statusIntervalRef.current = setInterval(checkStatus, 1000);\n    }\n    \n    return () => {\n      if (statusIntervalRef.current) {\n        clearInterval(statusIntervalRef.current);\n      }\n    };\n  }, [videoId]);\n\n  // Poll GIF status\n  useEffect(() => {\n    // Don't start polling if we're clearing or if there are no tasks\n    if (!videoId || isClearingRef.current || Object.keys(gifTasks).length === 0) {\n      return;\n    }\n    \n    const checkGIFStatus = async () => {\n      // Don't check if we're clearing\n      if (isClearingRef.current) {\n        return;\n      }\n      \n      try {\n        const status = await getGIFStatus(videoId);\n        const newGifTasks = status.gif_tasks || {};\n        \n        // Don't update if we're clearing\n        if (isClearingRef.current) {\n          return;\n        }\n        \n        // Only update if there are actually tasks\n        if (Object.keys(newGifTasks).length > 0) {\n          setGifTasks(newGifTasks);\n          \n          // Check if all tasks are completed or failed\n          const allDone = Object.values(newGifTasks).every(\n            task => task.status === 'completed' || task.status === 'failed'\n          );\n          \n          if (allDone && gifStatusIntervalRef.current) {\n            clearInterval(gifStatusIntervalRef.current);\n            gifStatusIntervalRef.current = null;\n          }\n        } else {\n          // Backend has no tasks, stop polling\n          if (gifStatusIntervalRef.current) {\n            clearInterval(gifStatusIntervalRef.current);\n            gifStatusIntervalRef.current = null;\n          }\n          setGifTasks({});\n        }\n      } catch (error) {\n        console.error('Error checking GIF status:', error);\n      }\n    };\n    \n    checkGIFStatus();\n    gifStatusIntervalRef.current = setInterval(checkGIFStatus, 1000);\n    \n    return () => {\n      if (gifStatusIntervalRef.current) {\n        clearInterval(gifStatusIntervalRef.current);\n        gifStatusIntervalRef.current = null;\n      }\n    };\n  }, [videoId, gifTasks]);\n\n  const handleYouTubeDownload = async (url) => {\n    try {\n      const result = await downloadVideo(url);\n      setVideoId(result.video_id);\n      setVideoStatus({ status: 'downloading', progress: 0 });\n    } catch (error) {\n      console.error('Error downloading video:', error);\n      alert('Error downloading video: ' + error.message);\n    }\n  };\n\n  const handleVideoUpload = async (file) => {\n    try {\n      const result = await uploadVideo(file);\n      setVideoId(result.video_id);\n      setVideoStatus({ status: 'uploading', progress: 0 });\n    } catch (error) {\n      console.error('Error uploading video:', error);\n      alert('Error uploading video: ' + error.message);\n    }\n  };\n\n  const handleProcessGIFs = async (configs, method, params) => {\n    if (!videoId) {\n      alert('Please download or upload a video first');\n      return;\n    }\n    \n    try {\n      const result = await processGIFs(videoId, configs, method, params);\n      setGifTasks(result.gif_tasks || {});\n    } catch (error) {\n      console.error('Error processing GIFs:', error);\n      alert('Error processing GIFs: ' + error.message);\n    }\n  };\n\n  return (\n    <div className=\"App\">\n      <header className=\"App-header\">\n        <h1>GIF Generator</h1>\n        <p>Generate multiple GIFs from videos</p>\n      </header>\n      \n      <div className=\"App-input-section\">\n        <VideoInput\n          onYouTubeDownload={handleYouTubeDownload}\n          onVideoUpload={handleVideoUpload}\n          videoStatus={videoStatus}\n        />\n      </div>\n      \n      <div className=\"App-container\">\n        <div className=\"App-left\">\n          <VideoPreview\n            videoUrl={videoUrl}\n            videoStatus={videoStatus}\n            onDimensionsChange={setVideoDimensions}\n            lineOverlays={lineOverlays}\n            dragEnabled={cropMethod === 'drag'}\n            dragRegions={dragRegions}\n            onDragRegionsChange={setDragRegions}\n            videoDimensions={videoDimensions}\n            cropMethod={cropMethod}\n            onLinePositionUpdate={cropMethod === 'lines' ? (type, index, value) => {\n              // Update lineOverlays immediately for visual feedback\n              if (type === 'horizontal') {\n                setLineOverlays(prev => {\n                  const newHorizontal = [...(prev.horizontal || [])];\n                  if (newHorizontal[index] !== undefined) {\n                    newHorizontal[index] = value;\n                  }\n                  return { ...prev, horizontal: newHorizontal };\n                });\n              } else if (type === 'vertical') {\n                setLineOverlays(prev => {\n                  const newVertical = [...(prev.vertical || [])];\n                  if (newVertical[index] !== undefined) {\n                    newVertical[index] = value;\n                  }\n                  return { ...prev, vertical: newVertical };\n                });\n              }\n            } : undefined}\n          />\n        </div>\n        \n        <div className=\"App-right\">\n          <CropConfig\n            cropMethod={cropMethod}\n            onCropMethodChange={setCropMethod}\n            videoDimensions={videoDimensions}\n            gifConfigs={gifConfigs}\n            onGifConfigsChange={setGifConfigs}\n            onProcessGIFs={handleProcessGIFs}\n            videoId={videoId}\n            videoReady={videoStatus?.status === 'ready'}\n            onLineOverlaysChange={setLineOverlays}\n            dragRegions={dragRegions}\n            onDragRegionsChange={setDragRegions}\n          />\n        </div>\n      </div>\n      \n      <div className=\"App-gallery\">\n        <GIFGallery \n          gifTasks={gifTasks} \n          onClearGIFs={async () => {\n            // Set clearing flag\n            isClearingRef.current = true;\n            \n            // Stop polling immediately\n            if (gifStatusIntervalRef.current) {\n              clearInterval(gifStatusIntervalRef.current);\n              gifStatusIntervalRef.current = null;\n            }\n            \n            // Clear frontend state immediately\n            setGifTasks({});\n            \n            // Clear backend\n            if (videoId) {\n              try {\n                await clearGIFs(videoId);\n              } catch (error) {\n                console.error('Error clearing GIFs from backend:', error);\n              }\n            }\n            \n            // Reset clearing flag after a short delay\n            setTimeout(() => {\n              isClearingRef.current = false;\n            }, 500);\n          }}\n        />\n      </div>\n    </div>\n  );\n}\n\nexport default App;\n\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}